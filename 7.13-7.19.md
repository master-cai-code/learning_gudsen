## 7.13
### 1.Mybatis进一步认识
       1.1 column的值是select出来的列名(不一定是数据库中的字段 虽然绝大多数是数据库字段 那是因为你默认取出来的列名没有改变就是用的数据库的字段)
       1.2 resultType 没有进行映射 直接对应字段赋值的java对象 ; resultMap 进行了映射 字段按映射赋值给对象的对应属性(数据库的查询结果==>Java对象)
             没有映射上的属性为null   默认值
       1.3 collection 一对多映射 (书写就是该类里面有个List<XXX> 属性  其他类的多个对象)   多对多就是两个一对多
           association   一对一和 多对一  (书写就是 类里面还有其他类的单个对象)
       1.4 一个完整(可能还有补充)的xml 里的sql语句 应该包括    按各种条件查询、按需要选择性的增加、按需要选择性的更新、按主键删除
                查询应该考虑 总数、排序和分页(多表查所有 用left join)    还有种查询 是查是否存在 (用limit 1)
                增加 考虑是否重复
                更新 也要查是否存在
                删除 也要查是否存在    (多表级联的时候 还要自己判断是否可以删除) (要先删从表 再删主表----因为从表引用主表 如果先删主表的话 这个引用就是"空指针" 失去意义)
         在进行这些操作之前  controller层会进行一次参数校验(确保增加、更新、删除的合法性)  查询若参数为空 则是where子句后面为空 没有任何条件 ===> 查所有
 
### 2.SpringMVC -- controller层的进一步认识
        2.1 @RequestParam 用来接收 Content-Type : x-www-form-urlencoded 的提交方式(不指定则默认是这种 form-urlencoded)  可以接收 基本类型和 对象
        2.2 @RequestBody 用来接收 Content-Type 除x-www-form-urlencoded之外的其他提交方式  一般是post请求  application/json 
        2.3 @Valid 只是单纯标记要验证 ; @Validate 则可以指定groups 指定验证的字段

## 7.14
    人人开源、FEBS权限系统、mall商城、畅购商城、代码生成器...
    easyExcel可以导入、导出Excel ;  hutool工具包(一些常用工具类)
    
    泊松分布:单位时间内 事件发生次数的概率(网站一分钟有一万次访问量的概率，不同的次数概率铁定不同...当然近似服从二项分布左右对称概率还是会相等)  {次数}的概率
    指数分布:相邻事件发生的时间 间隔的概率(相邻两次访问的时间间隔有多久, 两次事件发生的间隔不同 概率铁定不同 随时间递减)                       {间隔}的概率

## 7.15
### 1. 邮件的发送和接收实战代码
    邮件协议:SMTP(发送协议)、POP3和IMAP(接收协议)
       1. 发送邮件的基本思路:
            开启邮箱设置 打开上述的发送和接收协议;再获取授权码 用于登录
            书写代码:连接发送服务器 host 、protocol、port等 ; 指明发送人  验证账户密码 ,指明接收账号 ; 指定发送内容(文本、网页、附件等等)   最后发送
            参考代码地址:   https://blog.csdn.net/qq_41151659/article/details/96475739
          
    2. 接收邮件 基本思路:
            连接 接收服务器 host、protocol、port ; 验证接收人账号密码 ; 获取一个叫 "INBOX"的文件 ,该文件包含了所有收到的文件  最后遍历读取文件
            参考代码地址:   https://blog.csdn.net/xyang81/article/details/7675160

## 7.16
### 1. 看"利用多线程写一个下载器"
        切割  再 合并  ----分治法
        通过URL链接新建一个连接,获取inputstream输入流 用来读取下载数据......待续..
### 2. Mybatis
       按条件查<where> <if test="XX!=null"> and XX_xx=#{XX}</if> </where>    字符串判null和""空串，其他只判null
          还有按照时间查传入startTime 和endTime 利用between and 查询
          查询先计算总数, 还要考虑排序 分页
       新建ReqVo用来接收前端传过来的参数    适当进行参数校验(条件查可以不校验，不传参数就是查所有;其他增改删至少要给个id)
       
### 3.枚举enum
        特殊的class   也有全参构造、getter()setter()方法    不同的是: 类的开头就要写枚举实例 ;实例名就是构造函数 后面跟参数;实例之间用逗号 最后用分号
        枚举类的values()方法返回所有的枚举实例      Arrays.stream(MyEnum.values()).forEach(System.out::println);   打印

## 7.17-7.19(周五周末)
### 1. 根据用户id找权限,鉴权
### 2. 数据库mysql原理
      2.1 索引 --主键索引和辅助索引(联合索引)
         InnoDB是聚集索引(索引和数据放在一起),主键索引下面存放的是数据,辅助索引下面存放的是主键(得到主键后还要去主键索引找真实数据---也称回表)
         采用B+树：叶子节点存放索引和数据,非叶子节点只有索引;叶子节点之间形成单链表,不然树的遍历要采用中序遍历
         想有效的使用辅助索引,必须满足"最左前缀"原则,  23***和2567 是可以比较的(比较是当做字符串比较,先比第一位得出谁大,一样再比较第二位...),而 **23 和2566 是无法比较的,所以索引将无效
      2.2 事务
         ACID 原子性、一致性、隔离性、持久性
         多事务问题：脏读、不可重复读、幻读
           隔离级别：读已提交、可重复读、串行化
           锁的等级：行锁             、表锁
           锁的思想: 悲观锁(争抢、独占)、乐观锁(版本号)
### 3.Nginx初探
      3.1 反向代理
         正向代理: 你不能直接访问谷歌,但可以通过先访问代理服务器,代理服务器去访问Google-----代理服务器替你去做事(你和代理服务器是一体)
         反向代理: 你去访问一个集群,无需记住所有可访问的服务器地址,可以只记住代理服务器的地址,代理服务器为你分配正确的子服务器响应你的请求-----代理服务器替 集群做事(代理服务器和集群是一体)
       一句话就是:正向代理 代理的是客户端(服务器不知道你的真实ip); 反向代理 代理的是服务器(你不知道服务器的真实ip)
            以上的"你"都代表"客户端"
      3.2 负载均衡
            1.轮询
            2.加权轮询
            3.ip 哈希
            4.随机
            5.最小连接
      3.3 动静分离  
      
      3.4 限流(基于漏桶算法)
          漏桶算法的原型: "外来水流"注入漏桶,漏桶底部有个洞,桶内的水以均匀的速度从小洞流出.
              以上"外来水流"就是外部大量的请求; "小洞流出的水"就是限流之后的请求  ; 桶起到了接收请求的作用, 小洞起到了限流的作用(限制单位时间内请求的速率)
          令牌桶算法: 桶里面放入令牌,每个请求处理的时候都要去消耗桶里的一个令牌(有令牌才能处理,没令牌就拒绝请求,限制了总请求的个数)
