## 7.20
### 1. 再次理解装饰者模式
     关于继承的理解吧, 子类会拥有父类的非私有属性 自己再定义一个同名的属性是不会"重写覆盖"的，而是保持两份 一份父类 一份自己的, 若自己未定义,则使用的是父类的(共用); 
           方法才存在overload重写, 方法里面调用的变量是自己本类的变量(调用的是父类方法 父类方法里面使用的变量是父类的变量)
       子类并不是把父类的属性和方法复制了一份,而是有个指针指向父类(始终是一份,不是复制成两份),首先在自己子类中找属性和方法,没找到再找父类的;
       但是在多态的时候(父类引用指向子类对象) 想使用子类有 而父类没有的方法 必须向下转型
### 2.fastJSON 高危漏洞 不要再使用了;用Gson 或JackSON
### 3.邮箱知识获取各种"箱型"
        1.    Folder folder = imap.getFolder("INBOX");   //获取收件箱
            
        2.    Folder folder = null;
              Folder defaultFolder = imap.getDefaultFolder();     //得到所有的箱(收件箱、退信、垃圾箱、已发送等等)
              Folder[] allFolder = defaultFolder.list();
            
              for(Folder eachFolder:allFolder){
                   System.out.println(eachFolder.getName());
                   if("退信".equals(eachFolder.getName()))          //遍历找到想要的
                        folder=eachFolder;
              }
## 7.21
### 1. 延时队列DelayQueue
         队列头部存放最先到期的Task,用poll(非阻塞式,队列头部没元素返回null)或take(阻塞式,没元素就await)
### 2. where 、group、having、聚集函数
         先用where的条件 筛选出合要求的数据 ; 再用group对数据进行分组 ;having 进一步筛选数据  select 出来的应该包含分组的列名
         where筛选的单位是行 , having筛选的是group by后的组  ;   where不能用聚集函数   而having可以用聚集函数 也可以用普通条件判断
