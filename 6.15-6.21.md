
## 6.15

### 1.分布式事务（多个分布在不同机器上的service共同完成"一整件事"）
      我认为的思想：  不同机器上的service互相不可见，只能借助"第三方"来"搭线".
       
#### 1.1 2PC(两阶段提交)(将分布式事务的提交拆分为 2 个阶段：prepare 和 commit/rollback)
    这个"第三方"起到一个调度中心的作用
    (所有service都会告诉它自己是否准备好，当所有service都准备好后，它发布"号令"，全体service再进行commit；有一个没准备好则全体rollback)
     缺点：
     在 prepare 阶段需要等待所有参与子事务的反馈，因此可能造成数据库资源锁定时间过长，不适合并发高以及子事务生命周期较长的业务场景。
     牺牲了一部分可用性来换取的一致性。
     
#### 1.2 TCC(补偿事务)Try Confirm Cancel 
   思想：    针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作  （发起方Try，接收方Confirm，遇到失败则Cancel）
   
#### 1.3 本地消息表...
  思想 ：
  
      消息生产方----需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。
       然后消息会经过 MQ 发送到消息的消费方。 如果消息发送失败，会进行重试发送。
         
    消息消费方----需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。
       如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

    生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。


## 6.16

### 1.NP完全问题(Nondeterministic Polynomial Complete)
      说人话就是：为了得到某个问题的解，必须暴力穷举所有组合的可能解，从中再选取最优解(在不知道密码的前提下，为了破解密码，必须穷举所有的可能密码)
     对于像旅行商问题(Traveling Salesman Problem),组合数太多(100个城市有100！种可能)，无法穷举解决....

## 6.17
### 1.内部类(类里面又定义一个类，该类是外部类的一个"成员"，为外部类提供服务)
     意义：隐藏了内部类的实现;可以间接实现多继承???
           静态内部类不需要依赖外围类的实例，独立于外围类，为外围类提供服务.
### 2.过滤器与拦截器
     2.1 过滤器 函数回调；拦截器 动态代理
     2.2 过滤器属于servlet，只能在web应用使用；拦截器 范围更广
     2.3 过滤器 所有请求 ； 拦截器 只拦截访问Controller的请求
     2.4 过滤器可以注入bean ； 拦截器不能注入(拦截器加载的时间点在springcontext之前???)
### 3.枚举enum(是一个"类"，拥有"增强的常量"，也可以有构造函数，成员方法)
     意义：改进常量定义public static final...,enum更加灵活(可以扩展自定义属性)
### 4.JDK动态代理和CGLib动态代理
     意义：动态"增强"一个方法，起到不修改原方法也能进行功能上的增强
     实现思想：JDK动态代理（被代理对象 和 代理对象 实现一个共同接口）被代理对象和代理对象proxy 是"平级关系"
              CGLib：代理对象是被代理的子类 利用 [[proxy.invokeSuper(obj, arg);]] 调用父类要增强的方法  继承关系 
              
### 5.函数回调(你去调他的方法，他又来调用你的实现)
###     (例如：设明早七点的闹钟，我设置了闹铃"hall of fame",第二天早上手机在响铃的时候，就去找我指定的闹铃并播放)
     意义：系统或者框架 预留了一个必须要做的"操作"，但是这个操作的具体实现未知 或者 用户可以修改系统原有的操作 完成自定义的；
             在系统执行时，用户发送指令让系统去完成操作，系统接到命令后 调用用户指定的方法 操作完成 
     参考地址：https://www.jb51.net/article/126546.htm
