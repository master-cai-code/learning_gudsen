
## 6.15

### 1.分布式事务（多个分布在不同机器上的service共同完成"一整件事"）
      我认为的思想：  不同机器上的service互相不可见，只能借助"第三方"来"搭线".
       
#### 1.1 2PC(两阶段提交)(将分布式事务的提交拆分为 2 个阶段：prepare 和 commit/rollback)
    这个"第三方"起到一个调度中心的作用
    (所有service都会告诉它自己是否准备好，当所有service都准备好后，它发布"号令"，全体service再进行commit；有一个没准备好则全体rollback)
     缺点：
     在 prepare 阶段需要等待所有参与子事务的反馈，因此可能造成数据库资源锁定时间过长，不适合并发高以及子事务生命周期较长的业务场景。
     牺牲了一部分可用性来换取的一致性。
     
#### 1.2 TCC(补偿事务)Try Confirm Cancel 
   思想：    针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作  （发起方Try，接收方Confirm，遇到失败则Cancel）
   
#### 1.3 本地消息表...
  思想 ：
  
      消息生产方----需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。
       然后消息会经过 MQ 发送到消息的消费方。 如果消息发送失败，会进行重试发送。
         
    消息消费方----需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。
       如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

    生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。


## 6.16

### 1.NP完全问题(Nondeterministic Polynomial Complete)
      说人话就是：为了得到某个问题的解，必须暴力穷举所有组合的可能解，从中再选取最优解(在不知道密码的前提下，为了破解密码，必须穷举所有的可能密码)
     对于像旅行商问题(Traveling Salesman Problem),组合数太多(100个城市有100！种可能)，无法穷举解决....
