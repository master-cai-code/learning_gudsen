## 2020
### ----6.8
####  1. VO、DTO、PO
     vo：页面数据(前端传给后端，后端传给前端的数据，封装成对象) /// 参数校验@Validated  @NotNull等
     dto：数据传输对象，前端传给服务层，服务层按需要 封装???
     po: 一个对象对应数据库的一张表
     
####   2. 利用git提交项目（success）
     2.1 到想打开的文件位置，右键git bash here，
     2.2 git clone 地址 ，把远程项目克隆到当前文件位置
     2.3 用IDEA 选择打开文件
     2.4 进行编写
     2.5 代码完成后，右键项目 "Git" ==>"Add" ==> "Commit Directory" 选择被修改或添加的代码（只能是src或pom等配置文件，.gradle等带"."的
     文件，以及编译等到的文件"target"不要提交），填写提交记录信息 ==> "Repository" ==> "Push"=====>
                      最终:   Push successful: Pushed 1 commit to origin/master
                          
     过程命令： 远程仓库(clone) ------> 本地仓库(checkout)----->工作区
               [IDEA] 工作区(add)-------->暂存区(commit) ----->本地仓库(push)----->远程仓库(✔✔) 

### ----6.9
####  1.动态sql
     <where>标签用来  添加where关键字，去掉where条件开头多余的and
     <set>标签用来  添加set关键字，去掉末尾多余逗号
     <trim>标签可以指定开头和结尾添加什么，去掉什么（可以用户自定义叭）
     
     
####  2.回调函数的理解(还有待深入....)
      底层声明了一个函数，用户对此函数进行自定义，底层在调用这个函数时，调用 这个用户实现的函数
      you call me ，I will call back
      客户端程序A想调用服务端C的方法，然而服务端C又反过来调用客户端A的某个方法
           
      更加灵活.....把函数当做参数，可以有不同的实现；
### ★★★★ java没有指针，不能把函数地址传过去，用接的实现对象接收（不能传函数，但是可以传对象，对象可以调用函数，间接达到目的），
         用户可以自定义实现接口里的抽象方法，当调用接口的抽象方法时，由于子类重写 会调用子类的实现方法；
         关于子类实现接口： 1. 直接implement  2.匿名对象 new 接口名（）{重写的方法} 3.lambda表达式（仅限函数式接口，只有一个抽象方法的接口）


### ----6.10  ★★★★★算法概念，代码例子有待补充...
####  1.动态规划算法（由一个状态转移到另一个状态：以当前某个结果作为基础推"未知"）
    有两种：自顶向下 和 自底向上
    三种情况：线性模型（从左往右）、区间模型（中间向两边扩散???）、树型（自底向上）
####  2.贪心算法（局部最优就是全局最优）
     但有时候局部最优并不一定是全局最优，这个时候就不能用贪心算法得到全局最优解，改用动态规划???
####  3.回溯法（深度优先，一层一层往下找，再一层一层往上"回溯"）
     递归实现；有时在for循环里面调用递归，for循环用于向左平移、递归用于向下查找
          过程：（一边向下 （底层）搜索，找不到或找到底了再向上"回溯"，回溯到上一层再向左（平级）平移）
####  4.分支限界法（广度优先，"广播式"扩散）
     队列实现；一个"节点"进队，他的所有"孩子"也依次进队，不满足条件的可以"剪掉" "断子绝孙"
####  5.分治法（分而治之，分成一个一个"小块","小块"再聚合成"大块"）
     递归实现(类似于 树的前中后序)
        二叉树的前序（先访问"根节点"自己，再访问"左子树" "右子树"  每一个节点都如此 从上往下）
        二叉树的中序(先访问"左子树"，再访问"根节点"  "右子树" 每个节点都如此，   从下往上)
        二叉树的后序(先访问"左子树" "右子树"   最后"根节点"  每个节点都如此     从下往上)
