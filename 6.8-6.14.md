## 2020
### ----6.8
####  1. VO、DTO、PO
     vo：页面数据(前端传给后端，后端传给前端的数据，封装成对象) /// 参数校验@Validated  @NotNull等
     dto：数据传输对象，前端传给服务层，服务层按需要 封装???
     po: 一个对象对应数据库的一张表
     
####   2. 利用git提交项目（success）
     2.1 到想打开的文件位置，右键git bash here，
     2.2 git clone 地址 ，把远程项目克隆到当前文件位置
     2.3 用IDEA 选择打开文件
     2.4 进行编写
     2.5 代码完成后，右键项目 "Git" ==>"Add" ==> "Commit Directory" 选择被修改或添加的代码（只能是src或pom等配置文件，.gradle等带"."的
     文件，以及编译等到的文件"target"不要提交），填写提交记录信息 ==> "Repository" ==> "Push"=====>
                      最终:   Push successful: Pushed 1 commit to origin/master
                          
     过程命令： 远程仓库(clone) ------> 本地仓库(checkout)----->工作区
               [IDEA] 工作区(add)-------->暂存区(commit) ----->本地仓库(push)----->远程仓库(✔✔) 

### ----6.9
####  1.动态sql
     <where>标签用来  添加where关键字，去掉where条件开头多余的and
     <set>标签用来  添加set关键字，去掉末尾多余逗号
     <trim>标签可以指定开头和结尾添加什么，去掉什么（可以用户自定义叭）
     
     
####  2.回调函数的理解(还有待深入....)
      底层声明了一个函数，用户对此函数进行自定义，底层在调用这个函数时，调用 这个用户实现的函数
      you call me ，I will call back
      客户端程序A想调用服务端C的方法，然而服务端C又反过来调用客户端A的某个方法
           
      更加灵活.....把函数当做参数，可以有不同的实现；
### ★★★★ java没有指针，不能把函数地址传过去，用接的实现对象接收（不能传函数，但是可以传对象，对象可以调用函数，间接达到目的），
         用户可以自定义实现接口里的抽象方法，当调用接口的抽象方法时，由于子类重写 会调用子类的实现方法；
         关于子类实现接口： 1. 直接implement  2.匿名对象 new 接口名（）{重写的方法} 3.lambda表达式（仅限函数式接口，只有一个抽象方法的接口）


### ----6.10  ★★★★★算法概念，代码例子有待补充...
####  1.动态规划算法（由一个状态转移到另一个状态：以当前某个结果作为基础推"未知"）
    有两种：自顶向下 和 自底向上
    三种情况：线性模型（从左往右）、区间模型（中间向两边扩散???）、树型（自底向上）
####  2.贪心算法（局部最优就是全局最优）
     但有时候局部最优并不一定是全局最优，这个时候就不能用贪心算法得到全局最优解，改用动态规划???
####  3.回溯法（深度优先，一层一层往下找，再一层一层往上"回溯"）
     递归实现；有时在for循环里面调用递归，for循环用于向左平移、递归用于向下查找
          过程：（一边向下 （底层）搜索，找不到或找到底了再向上"回溯"，回溯到上一层再向左（平级）平移）
####  4.分支限界法（广度优先，"广播式"扩散）
     队列实现；一个"节点"进队，他的所有"孩子"也依次进队，不满足条件的可以"剪掉" "断子绝孙"
####  5.分治法（分而治之，分成一个一个"小块","小块"再聚合成"大块"）
     递归实现(类似于 树的前中后序)
        二叉树的前序（先访问"根节点"自己，再访问"左子树" "右子树"  每一个节点都如此 从上往下）
        二叉树的中序(先访问"左子树"，再访问"根节点"  "右子树" 每个节点都如此，   从下往上)
        二叉树的后序(先访问"左子树" "右子树"   最后"根节点"  每个节点都如此     从下往上)
        
        
        
### ----6.11 
#### 1. 尝试读Spring源码  IOC --->如何创建bean?---> 如何管理bean，把bean注入给程序?
       什么map，什么工厂模式，什么解耦
#### 2. java对象和Json对象的互转(Gson\fastJson)
      JSON的值有四种：       数字(5)， 字符串("xxx"), 对象({ }),  数组([ ])
      对应java中的类型为     Integer    String         类         List<>

### ----6.12-6.14（周五和周末）
#### 1.OpenGL初步认识(描点划线；填像素；补颜色（也称纹理）；输出)
     CPU 的图形处理的不足 催生出 GPU的诞生
                         (✘✘) CPU更擅长算术和逻辑计算，GPU擅长(✘✘)
   
    CPU大部分面积为控制器和寄存器；与之相比，GPU拥有更多的ALU（Arithmetic Logic Unit，逻辑运算单元）用于数据处理，而非数据高速缓存和流控制，这样的结构适合对密集型数据进行并行处理。
    CPU执行计算任务时，一个时刻只处理一个数据，不存在真正意义上的并行，而GPU具有多个处理器核，在一个时刻可以并行处理多个数据
    
    光栅化：把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。


#### 2.布隆过滤器(海量数据中判断一个数据是否存在)(布隆认为存在，则不一定存在；布隆认为不存在，则一定不存在)
     思想：利用位图bitmap,经过三次哈希映射，存在将此位设置为1，不存在设置为0 ；当然哈希表会不可避免的产生哈希碰撞，导致误判(不存在的元素被认为存在)，此 误判率默认为0.03，当然碰撞几率很小；
     但是★★★布隆过滤器认为不存在的元素就一定不存在!!!
     可以用来预防很多恶意的 "缓存击穿"
