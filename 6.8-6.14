## 2020
### ----6.8
  1. VO、DTO、PO
     vo：页面数据(前端传给后端，后端传给前端的数据，封装成对象) /// 参数校验@Validated  @NotNull等
     dto：数据传输对象，前端传给服务层，服务层按需要 封装???
     po: 一个对象对应数据库的一张表
     
   2. 利用git提交项目（success）
     2.1 到想打开的文件位置，右键git bash here，
     2.2 git clone 地址 ，把远程项目克隆到当前文件位置
     2.3 用IDEA 选择打开文件
     2.4 进行编写
     2.5 代码完成后，右键项目 "Git" ==>"Add" ==> "Commit Directory" 选择被修改或添加的代码（只能是src或pom等配置文件，.gradle等带"."的
     文件，以及编译等到的文件"target"不要提交），填写提交记录信息 ==> "Repository" ==> "Push"=====>
                      最终:   Push successful: Pushed 1 commit to origin/master
                          
     过程命令： 远程仓库(clone) ------> 本地仓库(checkout)----->工作区
               [IDEA] 工作区(add)-------->暂存区(commit) ----->本地仓库(push)----->远程仓库(✔✔) 

### ----6.9
  1.动态sql
     <where>标签用来  添加where关键字，去掉where条件开头多余的and
     <set>标签用来  添加set关键字，去掉末尾多余逗号
     <trim>标签可以指定开头和结尾添加什么，去掉什么（可以用户自定义叭）
     
     
  2.回调函数的理解(还有待深入....)
      底层声明了一个函数，用户对此函数进行自定义，底层在调用这个函数时，调用 这个用户实现的函数
      you call me ，I will call back
      客户端程序A想调用服务端C的方法，然而服务端C又反过来调用客户端A的某个方法
           
      更加灵活.....把函数当做参数，可以有不同的实现；
 ★★★★ java没有指针，不能把函数地址传过去，用接的实现对象接收（不能传函数，但是可以传对象，对象可以调用函数，间接达到目的），
         用户可以自定义实现接口里的抽象方法，当调用接口的抽象方法时，由于子类重写 会调用子类的实现方法；
         关于子类实现接口： 1. 直接implement  2.匿名对象 new 接口名（）{重写的方法} 3.lambda表达式（仅限函数式接口，只有一个抽象方法的接口）
