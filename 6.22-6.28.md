## 6.22
### 1.泛型类与泛型方法
         类(或接口)后面有<T>,参数类型和方法里面可以不用声明直接用T
         类(或接口)上面没有<T>,方法要用时在 static 和 返回值之间加上<T>，再使用
         
### 2.Spring IOC的循环依赖(A->B,B->C,C->A...)
    打破循环依赖的条件:在"依赖环"中有一个bean是singleton,并且是通过属性注入依赖(setter方法注入)而非构造器,
             原因:利用setter方法注入依赖时，可以先用默认的构造函数生成这个对象实例，之后再给属性注入值;而如果直接用构造函数注入的话,构造函数参数不完整,
             导致对象迟迟未创建成功,多个对象都没创建成功导致集体"瘫痪". singleton保证对象全局唯一
             
    参考地址:     https://blog.csdn.net/ZXW601498616/article/details/88868841
    
      /** Cache of singleton objects: bean name --> bean instance */存放单例的bean,"成熟的"bean，已赋值可以使用了                   顺序3
      private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);
      
      /** Cache of singleton factories: bean name --> ObjectFactory */临时存放各种待创建的bean 所以是factory                       顺序1
      private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);
      
      /** Cache of early singleton objects: bean name --> bean instance */ bean的早期引用，只是创造出来了，属性都是null，等待赋值    顺序2
      private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);
      
      创建出来的顺序和依赖传递的顺序相反(A->B,B->C,C->A)--->创建顺序(C--B--A)

## 6.23
### 1."<<",">>",">>>" 有符号的左移右移及无符号的右移
   对于有符号的移动，右移时高位(正数高位全部补0，负数高位全部补1); 无符号右移不管正负都补0
   有符号的左移右移对应数学运算乘、除2的幂次 (注意除的时候若不是整除即有小数,结果为比此数小的最大整数 数轴左边的第一个数---如( -18/4= -4.5)===> -5)
   
   -18 -----原码 1001 0010 ----- 取反 1110 1101 -----加一 1110 1110 ====>右移两位高位补一 1111 1011 ==== 减一 1111 1010 ==== 取反 1000 0101 ==== 得到最终结果 -5
   参考地址:https://blog.csdn.net/qq_23892379/article/details/79507732
   
### 2. mysql的count(*)查询效率.....
        mysql会用 成本最小的辅助索引查询方式来计数  CPU成本0.2 页面是1.....explain ......optimizer trace .......?????
