## 6.22
### 1.泛型类与泛型方法
         类(或接口)后面有<T>,参数类型和方法里面可以不用声明直接用T
         类(或接口)上面没有<T>,方法要用时在 static 和 返回值之间加上<T>，再使用
         
### 2.Spring IOC的循环依赖(A->B,B->C,C->A...)
    打破循环依赖的条件:在"依赖环"中有一个bean是singleton,并且是通过属性注入依赖(setter方法注入)而非构造器,
             原因:利用setter方法注入依赖时，可以先用默认的构造函数生成这个对象实例，之后再给属性注入值;而如果直接用构造函数注入的话,构造函数参数不完整,
             导致对象迟迟未创建成功,多个对象都没创建成功导致集体"瘫痪". singleton保证对象全局唯一
             
    参考地址:     https://blog.csdn.net/ZXW601498616/article/details/88868841
    
      /** Cache of singleton objects: bean name --> bean instance */存放单例的bean,"成熟的"bean，已赋值可以使用了                   顺序3
      private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);
      
      /** Cache of singleton factories: bean name --> ObjectFactory */临时存放各种待创建的bean 所以是factory                       顺序1
      private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);
      
      /** Cache of early singleton objects: bean name --> bean instance */ bean的早期引用，只是创造出来了，属性都是null，等待赋值    顺序2
      private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);
      
      创建出来的顺序和依赖传递的顺序相反(A->B,B->C,C->A)--->创建顺序(C--B--A)
