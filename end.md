## 8.12
### 1.Java的类初始化机制
     loader加载（将二进制码.class文件加载进虚拟机）
    ---> link 链接（验证语法的合法性、变量分配内存空间并先赋默认值、class文件中的符号引用换成直接引用）
    ---> initialization 初始化 (顺序:父类的所有静态代码块-->子类所有静态代码块 -->父类所有普通代码块-->父类构造函数  -->子类所有普通代码块 -->子类构造函数)
            对于同一个类来说，一般顺序: 成员变量-->静态块--> 普通块-->构造函数
            注意在执行构造函数之前一定会先执行  成员变量的赋值 --> 普通代码块    最后再构造函数

## 8.13
### 1.IOC的由来:
        当想调用一个类中的方法时，需要通过该类的对象调用方法，频繁的在不同类中创建对象  繁琐而且耦合度高，占用内存大;
        创建单例对象可以减少内存占用 但是依旧繁琐耦合度高  创建单例模板相似 重复度高；
        IOC由此诞生  对象的创建交给IOC容器处理  需要使用对象的时候，采用自动注入（按类型也可按照名字）
### 2.AOP的由来：
        当有段代码经常性反复出现时，第一想法就是提取为方法，在需要的地方引用该方法，但如果有上百个地方引用该方法 写一百遍xxx() 也太繁琐；
        面向切面由此诞生，在指定的pointcut 指定时间（before、after、around、afterreturing） 做advice   （相当于是框架给你循环每个pointcut做了增强）
        动态代理：JDK（需要实现一个共同接口）
                 CGLib（子类继承父类，扩展父类方法）
  
## 8.14
### 1.Mysql可重复读的实现
        问题:事务一读了一次数据，事务二修改数据并且成功提交，事务一再来读数据发现读取的数据和第一次不一样------不可重复读（事务一 一直未提交，两次读是在一个事务里）
        实现方案：利用版本号，数据插入时有个create_version,删除时有个delete_version,修改相当于先删除原数据再新增数据（同时更改delete_version 和create_version）
          一个事务整个过程中（从begin到commit）读到的版本号是一致的，新来的事务会在前版本号上加一（一个事务一个全局的版本号）
          此版本号就是create_version??


## 8.19
### 1.Spring 事务
     隔离级别：(5个) 默认、读未提交、读已提交、可重复读、串行化
     传播级别：(7个) required：没事务，创建事务；有事务 加入此事务
                   requires_new:没事务，创建事务；有事务,挂起当前事务,自己新建事务
                   supports:没事务，以非事务执行；有事务，加入事务
                   not_supported:始终以非事务执行，有事务则挂起当前事务
                   mandatory：当前没事务就抛异常
                   never：始终以非事务执行，有事务就抛异常
                   nested：嵌套事务
                   
### 2. 编程式事务和声明式事务：
         基于 TransactionDefinition、PlatformTransactionManager、TransactionStatus 编程式事务管理是 Spring 提供的最原始的方式;
                       基于 TransactionTemplate 的编程式事务管理是对上一种方式的封装，使得编码更简单、清晰。
         基于 @Transactional 的方式将声明式事务管理简化到了极致
     























